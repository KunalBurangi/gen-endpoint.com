
'use server';
/**
 * @fileOverview Flow to generate a dynamic JSON response from an AI based on a path slug, user query, HTTP method, and request body.
 *
 * - generateRuntimeResponse - A function that generates a JSON response.
 * - GenerateRuntimeResponseInput - The input type for the generateRuntimeResponse function.
 * - GenerateRuntimeResponseOutput - The return type for the generateRuntimeResponse function.
 */

import { genkit } from 'genkit';
import { googleAI } from '@genkit-ai/googleai';
import { ai as globalAi } from '@/ai/genkit';
import { z } from 'genkit';

const GenerateRuntimeResponseInputSchema = z.object({
  pathSlug: z.string().describe("The conceptual path for which data is being generated, e.g., 'mobiles/brands' or 'user/profile'."),
  userQuery: z.string().describe("The specific query or instruction from the user for what data to generate, e.g., 'list top 5 flagship models' or 'a user object with name and email'."),
  httpMethod: z.string().describe("The HTTP method for the request (GET, POST, PUT, PATCH, DELETE)."),
  requestBody: z.string().optional().describe("The JSON request body, if applicable (for POST, PUT, PATCH)."),
  userApiKey: z.string().optional().describe('User-provided Google AI API key.')
});
export type GenerateRuntimeResponseInput = z.infer<typeof GenerateRuntimeResponseInputSchema>;

const GenerateRuntimeResponseOutputSchema = z.object({
  jsonResponse: z.string().describe("A JSON string dynamically generated by an AI based on the user's query for the given path context, HTTP method, and request body. This should be raw JSON data only."),
});
export type GenerateRuntimeResponseOutput = z.infer<typeof GenerateRuntimeResponseOutputSchema>;

export async function generateRuntimeResponse(input: GenerateRuntimeResponseInput): Promise<GenerateRuntimeResponseOutput> {
  return generateRuntimeResponseFlow(input);
}

const generateRuntimeResponseFlow = globalAi.defineFlow(
  {
    name: 'generateRuntimeResponseFlow',
    inputSchema: GenerateRuntimeResponseInputSchema,
    outputSchema: GenerateRuntimeResponseOutputSchema,
  },
  async (input) => {
    if (!input.userApiKey) {
      throw new Error("User API key is required for this operation.");
    }

    const customGenkit = genkit({ plugins: [googleAI({ apiKey: input.userApiKey })] });
    
    const systemPrompt = `You are an AI that generates JSON data for a dynamic API endpoint.
The HTTP method for this request is: ${input.httpMethod.toUpperCase()}.
The conceptual path for this data is '/${input.pathSlug}'.
The user's original prompt for what this endpoint should ideally do or represent is: '${input.userQuery}'.
${input.requestBody ? `The request body sent by the user (if any, for POST/PUT/PATCH) was: '${input.requestBody}'. You should consider this body when forming your response.` : 'No request body was provided or it is not applicable for this method.'}

Based on all this information (method, path, user query, and request body if provided), generate a concise and relevant JSON response.
For example:
- If the method is GET, return the requested data.
- If the method is POST, the response might indicate successful creation of a resource, possibly returning the created resource or a confirmation.
- If the method is PUT or PATCH, the response might indicate successful update, possibly returning the updated resource.
- If the method is DELETE, the response might indicate successful deletion.

IMPORTANT: Only output the raw JSON data, nothing else. Do not include markdown formatting like \`\`\`json ... \`\`\` around the JSON object.
The response must be a valid JSON string.`;

    console.log("Reaching generateRuntimeResponseFlow with input before generate:");
    const response = await customGenkit.generate({
      model: 'googleai/gemini-2.0-flash',
      prompt: systemPrompt,
      output: { schema: GenerateRuntimeResponseOutputSchema },
    });
    
    const output = response.output;
    if (!output || !output.jsonResponse) {
      console.error("AI response was empty or could not be parsed to GenerateRuntimeResponseOutputSchema. Raw response text:", response.text);
      const errorText = response.text ?? "No error text available from AI response.";
      throw new Error(`AI response could not be parsed to the expected JSON format. AI message: ${errorText}`);
    }
    // Ensure the response is actually valid JSON before returning
    try {
      JSON.parse(output.jsonResponse);
    } catch (e) {
      console.error("AI output.jsonResponse was not valid JSON. Content:", output.jsonResponse);
      throw new Error(`AI generated data that was not valid JSON. Please try rephrasing your query or try again. AI output: ${output.jsonResponse.substring(0,100)}...`);
    }
    return output;
  }
);
